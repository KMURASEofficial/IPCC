#include "encrypt.h"
#include "rng.h"
#include "invpoly.h"
#include <stdlib.h>
#include <stdint.h>

void get_neig(graph *g, const uint8_t (*edge)[2]) {
	uint8_t index[VERTEXES] = { 0, };

	for (int i = 0; i < VERTEXES; i++) {
		g->v[i].neig[0] = i; // neig[i][0] = i;
		index[i]++;
	}
	

	for (int i = 0; i < EDGES; i++) {
		uint8_t a = edge[i][0] % VERTEXES;
		uint8_t b = edge[i][1] % VERTEXES;

		g->v[a].neig[index[a]] = b; // neig[a][index[a]] = b;
		index[a]++;
		g->v[b].neig[index[b]] = a; // neig[b][index[b]] = a;
		index[b]++;
	}
}

void reduce_sort(invpoly *res, int dimk) {
	int temp;
	for (int i=0; i<TERM; i++) {
		if ( !res->d[i].coeffs ) break;
		for (int j=0; j<dimk; j++) {
			for (int k=0; k<dimk-1; k++) {   // 요소의 개수 - 1만큼 반복
				if (res->d[i].v[k] > res->d[i].v[k+1] || res->d[i].v[k]==0) {         // 현재 요소의 값과 다음 요소의 값을 비교하여
					temp = res->d[i].v[k];
					res->d[i].v[k] = res->d[i].v[k+1];
					res->d[i].v[k+1] = temp;            // 다음 요소로 보냄
				}
			}
		}
	}
}

// 함수명 reduce_degree로 변경
void reduce_dim(invpoly *res, invpoly *p, int dimk) {
	int j, check;
	uint8_t offset;
	for ( int i=0; i<TERM; i++ ) {
		if ( !p->d[i].coeffs ) break; // 다항식의 끝이면 break;
		res->d[i].coeffs=p->d[i].coeffs;
		res->d[i].v[0]=p->d[i].v[0];
		offset=1;
		for ( int j=1; j<dimk-1; j++ ) {
			for ( int k=j; k<dimk; k++ ) {
				if ( p->d[i].v[j] != p->d[i].v[k] ) {
					check=0;
					for ( int l=0; l<dimk; l++ ) {
						if ( res->d[i].v[l]==p->d[i].v[j] ) check=1;
					}
					if (check==0) res->d[i].v[offset++]=p->d[i].v[j];
					if (offset==dimk) break;
					check=0;
					for ( int l=0; l<dimk; l++ ) {
						if ( res->d[i].v[l]==p->d[i].v[k] ) check=1;
					}
					if (check==0) res->d[i].v[offset++]=p->d[i].v[k];
					if (offset==dimk) break;
				}
			}
		}
	}
}

int isneigd2(uint8_t v1, uint8_t v2, const graph *g) {
	for (int i=0; i<4; i++) {
		for (int j=0; j<4; j++) {
			if ( !(g->v[v1].neig[i] ^ g->v[v2].neig[j]) ) { // d<=2인경우
				return 1;
			}
		}
	}
	return 0;
}

void reduce_neig(invpoly *res, const graph *g, int dimk, int *length) {
	for (int i=0; i<TERM; i++) {
		if ( !res->d[i].coeffs ) {
			*length=i-1; // term의 개수
			break;
		}
		for (int j=0; j<dimk-1; j++) {
			if ( res->d[i].v[j]==0 ) break; // term[i]에 0이 나오면 pass
			// g->v[res->d[i].v[pos1]], g->v[res->d[i].v[pos2]]가 이웃이면 그 term 삭제
			// g->v[0].neig[0~4] |g->v[1].neig[0~4] > 0 이면 삭제
			for (int k=j+1; k<dimk; k++) {
				if ( res->d[i].v[k]==0 ) break;
				if ( isneigd2(res->d[i].v[j], res->d[i].v[k], g)==1 ) {
					// 이 항은 삭제
					res->d[i].coeffs=0; // 삭제 표지
					break;
				}
			}
			if (res->d[i].coeffs==0) break;
		}
	}
}

void reduce_dup(invpoly *res, invpoly *p, int dimk, int *length) {
	int dup=0;
	int dupcnt=0;
	// O(n^2) -> 이게 좀 느림
#ifdef REDUCE_DUP
	for (int i=0; i<=*length-1; i++) { // term1
		if (p->d[i].coeffs==0) continue;
		for (int j=i+1; j<=*length; j++) { // term2
			if (p->d[j].coeffs==0) continue;
			dup=1;
			for (int k=0; k<dimk; k++) {
				if (p->d[i].v[k] != p->d[j].v[k]) {
					dup=0; // term에 다른게 하나라도 있으면 두개는 다른 term
					break;
				}
			}
			if (dup==1) {
				p->d[j].coeffs=0;
				dupcnt++;
			}
		}
	}
#endif
	// printf("# of dup terms = %d\n", dupcnt); // 282

	int c=0;
	for (int i=0; i<=*length; i++) {
		if ( p->d[i].coeffs ) { // 유효한 항은
			res->d[c].coeffs = p->d[i].coeffs; // 계수 복사
			for (int j=0; j<dimk; j++)
				res->d[c].v[j]=p->d[i].v[j]; // 정점 복사
			c++;
		}
	}
	*length=c-1;
}

void poly_shuffle(invpoly *ct, int dimk, int *length) {
	uint32_t index;
	uint8_t temp;
	uint32_t coef_temp;
	for (int i=0; i<*length; i++) {
		index = randomint();
		index = (index % (*length+1)) % ((*length+1)-i) +i;
		// term[i] <-> term[index]
		for (int j=0; j<dimk; j++) {
			temp = ct->d[i].v[j];
			ct->d[i].v[j] = ct->d[index].v[j];
			ct->d[index].v[j] = temp;
		}
		coef_temp = ct->d[i].coeffs;
		ct->d[i].coeffs = ct->d[index].coeffs;
		ct->d[index].coeffs = coef_temp;
		
	}
}

int poly_mul(invpoly *p, invpoly *p1, invpoly *p2, int k1, int k2) {
	uint32_t c=0;
	for (int i=0; i<TERM; i++) {
		if ( !p1->d[i].coeffs ) break;
		for (int j=0; j<TERM; j++) {
			if ( !p2->d[j].coeffs ) break;
			p->d[c].coeffs = (uint32_t) ((uint64_t) p1->d[i].coeffs * (uint64_t) p2->d[j].coeffs % Q); // type casting
			for (int k=0; k<k1; k++)
				p->d[c].v[k] = p1->d[i].v[k];
			for (int k=0; k<k2; k++)
				p->d[c].v[k+k1] = p2->d[j].v[k];
			c++;
		}
	}
	return 1;
}

// pds
//   0  47 170  16
//   1 215 131 151
//   2  93 100 135
//   3  97 229 244
//   4 214 109 107
//   5 241  44  16
//   6 243 193 159
//   7 180 126 128
//   8  52  99  51
//   9 190 193 186
//  10  46  64  66
//  11 217 118 143
//  12 105 145 168
//  13  94  46 254
//  14 154 112 111
//  15 200  86 118
//  16 236   0   5
//  17 126  95 208
//  18 203 212  74
//  19 184 240  34
//  20 195 102 156
//  21 195 237 248
//  22  41 229 219
//  23 174 148 233
//  24 201 147  68
//  25 127  88 136
//  26  61  44  78
//  27 122 146 211
//  28  94 211 244
//  29 175 216 189
//  30 202 191 139
//  31 253  98 233
//  32 215  69  85
//  33  45 101 254
//  34  48  69  19
//  35  80 145 177
//  36 180 234  85
//  37 120 182 111
//  38 213 217 167
//  39 127 146 178
//  40  77  49 189
//  41  57  60  22
//  42 205  70 124
//  43 242 151 248
//  44 119   5  26
//  45  33 179 249
//  46  10  13 204
//  47   0 219 250
//  48 141 209  34
//  49  40 223 123
//  50 110 128 107
//  51 214 108   8
//  52 162   8 114
//  53  55 252  87
//  54 175 239 132
//  55 240  63  53
//  56 121 212 161
//  57  41 194  92
//  58 150 188 186
//  59 155 206 246
//  60  41 245 161
//  61 252 247  26
//  62  98 182 176
//  63  55 155 137
//  64  10 218 224
//  65 221 170 230
//  66  10  90  95
//  67  90 228 187
//  68  24 117 209
//  69  84  32  34
//  70 198  42 114
//  71 160 112 106
//  72 102 167 106
//  73  83 103 249
//  74 150  18 192
//  75  84 154 247
//  76  94 104 115
//  77  40 235 164
//  78 175 201  26
//  79 190 121 140
//  80 145 191  35
//  81  96 231 168
//  82 195 115 140
//  83 103  73 178
//  84  69 179  75
//  85 251  36  32
//  86 127 132  15
//  87 197 108  53
//  88 197 157  25
//  89 218 231 113
//  90  67 247  66
//  91 160 240 153
//  92 202  57 199
//  93   2 192 143
//  94  28  13  76
//  95  17 162  66
//  96  81 153 169
//  97 188   3 226
//  98  62  31 176
//  99 122   8 114
// 100   2 255 181
// 101  33 171 250
// 102  72 149  20
// 103  83  73 163
// 104 215 209  76
// 105 255  12 186
// 106  72  71 144
// 107  50 121   4
// 108 253  87  51
// 109 225   4 159
// 110  50 128 135
// 111  14  37 116
// 112  14  71 163
// 113  89 183 232
// 114  52  99  70
// 115 122  82  76
// 116 202 252 111
// 117 198 185  68
// 118  11 141  15
// 119  44 177 204
// 120  37 132 248
// 121  56  79 107
// 122  99 115  27
// 123 184 155  49
// 124 173  42 228
// 125 205 238 148
// 126  17 152   7
// 127  86  39  25
// 128  50 110   7
// 129 158 245 194
// 130 165 201 152
// 131 213 144   1
// 132 120  86  54
// 133 239 149 163
// 134 223 156 137
// 135   2 110 147
// 136 200 220  25
// 137 134 162  63
// 138 165 147 187
// 139 210  30 185
// 140 253  82  79
// 141  48 118 208
// 142 210 221 189
// 143  11  93 206
// 144 173 131 106
// 145  80  12  35
// 146 214  39  27
// 147  24 138 135
// 148  23 174 125
// 149 133 102 222
// 150 245  58  74
// 151 236  43   1
// 152 213 126 130
// 153  96 154  91
// 154  14 153  75
// 155  59  63 123
// 156 134 166  20
// 157 165  88 246
// 158 237 235 129
// 159   6 109 212
// 160  71 216  91
// 161  56 255  60
// 162  52  95 137
// 163 133 103 112
// 164 242  77 216
// 165 138 157 130
// 166 173 156 246
// 167  72 183  38
// 168 190  81  12
// 169  96 188 193
// 170  65   0 230
// 171 251 101 181
// 172 236 228 233
// 173 166 144 124
// 174  23 148 250
// 175  29  78  54
// 176  62  98 231
// 177 119 196  35
// 178  83 221  39
// 179  84  45 226
// 180  36 211   7
// 181 241 171 100
// 182  62  37 187
// 183 241 167 113
// 184 229  19 123
// 185 203 117 139
// 186 105   9  58
// 187  67 138 182
// 188  97  58 169
// 189  40  29 142
// 190   9  79 168
// 191  80  30 204
// 192 251  93  74
// 193   6   9 169
// 194 242  57 129
// 195  82  21  20
// 196 210 177 226
// 197  88  87 224
// 198 117  70 244
// 199 205 239  92
// 200 220 136  15
// 201  24  78 130
// 202  30 116  92
// 203  18 185 227
// 204 119  46 191
// 205  42 199 125
// 206  59 243 143
// 207 238 232 222
// 208  17 141 235
// 209  48 104  68
// 210 196 142 139
// 211 180  28  27
// 212  56  18 159
// 213 131 152  38
// 214 146   4  51
// 215 104  32   1
// 216 160  29 164
// 217  11 232  38
// 218  89  64 254
// 219  47 238  22
// 220 200 136 224
// 221  65 142 178
// 222 207 223 149
// 223 134  49 222
// 224 197 220  64
// 225 109 234 249
// 226  97 196 179
// 227 203 237 234
// 228  67 172 124
// 229 184   3  22
// 230  65 243 170
// 231  89  81 176
// 232 207 217 113
// 233  23 172  31
// 234 225  36 227
// 235 158  77 208
// 236 172 151  16
// 237 158  21 227
// 238 207 219 125
// 239 133 199  54
// 240  55  19  91
// 241 183   5 181
// 242  43 194 164
// 243   6 206 230
// 244 198  28   3
// 245 150  60 129
// 246  59 166 157
// 247  61  90  75
// 248 120  43  21
// 249 225  45  73
// 250  47 174 101
// 251 171 192  85
// 252  61 116  53
// 253 108  31 140
// 254  33 218  13
// 255 105 100 161